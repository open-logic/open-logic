<img src="../Logo.png" alt="Logo" width="400">

# olo_base_cc_xn2n

[Back to **Entity List**](../EntityList.md)

## Status Information

![Endpoint Badge](https://img.shields.io/endpoint?url=https://storage.googleapis.com/open-logic-badges/coverage/olo_base_cc_xn2n.json?cacheSeconds=0) ![Endpoint Badge](https://img.shields.io/endpoint?url=https://storage.googleapis.com/open-logic-badges/branches/olo_base_cc_xn2n.json?cacheSeconds=0) ![Endpoint Badge](https://img.shields.io/endpoint?url=https://storage.googleapis.com/open-logic-badges/issues/olo_base_cc_xn2n.json?cacheSeconds=0)

VHDL Source: [olo_base_cc_xn2n](../../src/base/vhdl/olo_base_cc_xn2n.vhd)

## Description

This component implements a clock crossing with AXI-S handshaking for transferring data from one clock domain to another one that runs at an integer fraction of the frequency of the input clock frequency. It can for example be used to transfer data from a 100 MHz clock domain to a 50 MHz clock domain (both generated by the same PLL).

Note that the two clocks must be phase aligned.

Note that the clock crossing **does not work if the two clocks have the same frequency**.

This block follows the general [clock-crossing principles](clock_crossing_principles.md). Read through them for more information.

## Generics

| Name    | Type     | Default | Description         |
| :------ | :------- | ------- | :------------------ |
| Width_g | positive | -       | Data width in bits. |

## Interfaces

### Input Data

| Name      | In/Out | Length    | Default | Description                                                  |
| :-------- | :----- | :-------- | ------- | :----------------------------------------------------------- |
| In_Clk    | in     | 1         | -       | Input clock (must run at an integer multiple of *Out_Clk*)   |
| In_RstIn  | in     | 1         | -       | Reset input (high-active, synchronous to *In_Clk*)           |
| In_RstOut | out    | 1         | N/A     | Reset output (see [clock-crossing principles](clock_crossing_principles.md), synchronous to *In_Clk*) |
| In_Data   | in     | *Width_g* | -       | Input data                                                   |
| In_Valid  | in     | 1         | '1'     | AXI4-Stream handshaking signal for *In_Data*                 |
| In_Ready  | out    | 1         | N/A     | AXI4-Stream handshaking signal for *In_Data*                 |

### Output Data

| Name       | In/Out | Length    | Default | Description                                                  |
| :--------- | :----- | :-------- | ------- | :----------------------------------------------------------- |
| Out_Clk    | in     | 1         | -       | Output clock                                                 |
| Out_RstIn  | in     | 1         | '0'     | Reset input (high-active, synchronous to *Out_Clk*)          |
| Out_RstOut | out    | 1         | N/A     | Reset output (see [clock-crossing principles](clock_crossing_principles.md), synchronous to *Out_Clk*) |
| Out_Data   | out    | *Width_g* | N/A     | Output data                                                  |
| Out_Valid  | out    | 1         | N/A     | AXI4-Stream handshaking signal for *Out_Data*                |
| Out_Ready  | in     | 1         | '1'     | AXI4-Stream handshaking signal for *Out_Data*                |

## Architecture

The architecture of the entity is simple, not detailed description is required.



